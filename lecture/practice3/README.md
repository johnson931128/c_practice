這個任務非常適合用來展示 std::set 這個容器的威力。
思考過程與步驟分解
分析問題需求：
輸入：一個 std::vector<std::string>，裡面可能包含重複的郵件地址。
輸出：所有不重複的郵件地址，並且需要按字母順序排序後印出。
選擇合適的容器：
我們需要一個能儲存 std::string 的容器。
這個容器需要滿足兩個關鍵特性：
唯一性：自動忽略重複的元素。
自動排序：容器內的元素總是有序的。
讓我們回顧一下學過的容器：
std::vector：不保證唯一性，也不會自動排序。不適合。
std::deque：同 vector。不適合。
std::map / std::unordered_map：是用來儲存鍵值對的，但我們這裡只有單一的值（郵件地址），沒有對應的值。有點大材小用。
std::unordered_set：保證唯一性，但元素是無序的。不滿足排序需求。
std::set：完美符合！ 它天生就是用來儲存唯一元素的，並且內部元素總是保持排序狀態。
設計演算法：
创建一个 std::set<std::string> 容器。
遍歷輸入的 std::vector<std::string>。
在遍歷過程中，將 vector 中的每一個郵件地址都用 .insert() 方法插入到 set 中。set 會自動處理一切：如果郵件地址已經存在，插入操作會被忽略；如果不存在，它會被插入到正確的排序位置。
當所有郵件地址都插入完畢後，set 中就只剩下所有不重複且已排好序的郵件地址。
最後，我們只需要遍歷這個 set，並將裡面的元素逐一印出即可。